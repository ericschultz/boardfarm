#!/usr/bin/env python
import argparse
import re
import sys
import pexpect
import os
import tempfile
import shutil

from devices import base

HELP_EPILOG = '''
Example use:

 bft -b ap148 --testsuite flash_only -m http://10.0.0.101/nand-ipq806x-single.img

 bft -b ap135 --testsuite preflight -r http://10.0.0.101/openwrt-ar71xx-generic-ap135-rootfs-squashfs.bin
'''

GET_STARTED = '''
This program prepares a system to run as a LAN or WAN system
with the tests run as a non-root user. This script is idempotent, i.e. if your
run it multiple times, it won't cause any problems.

Unless you've set the '-y' argument, we'll ask you whether you want particular
changes made to your system. In most cases, you should answer 'y'.
'''


class FakeDevice(base.BaseDevice):
    prompt = ['.+\\@.*:.*(\$|#)']
    def __init__(self):
        pexpect.spawn.__init__(self, command="bash")
        self.logfile_read = sys.stdout


    #we default to bin subdir
class SetupRunner(object):

    def __init__(self,username, type, test=True):
        self.device = FakeDevice()
        self.type = type
        self.username = username
        self.test = test

    def add_to_sudoers(self, template_file=None):
        if template_file is None:
            template_file = self.local_dir('conf', 'testing_sudoers')
        f = open(template_file, 'rb')
        lines = f.readlines()
        f.close()

        testing_cmds_to_tester_regexp = "^__username__"
        testing_cmds_to_tester_contents = "%s ALL=(ALL) NOPASSWD: TESTING_CMDS" % self.username
        self.replace_or_add_line(lines, testing_cmds_to_tester_regexp, testing_cmds_to_tester_contents)
        self.save_sudoers(lines)

    #inspired from Ansible but not enough to influence copyright
    def replace_or_add_line(self, lines, regex, line_to_make_present):
        line_num = -1
        mre = re.compile(regex)
        for lineno, cur_line in enumerate(lines):
            match_found = mre.search(cur_line)
            if match_found:
                line_num = lineno
        if line_num != -1:
            lines[line_num] = line_to_make_present
        else:
            if len(lines)>0 and not (lines[-1].endswith('\n') or lines[-1].endswith('\r')):
                lines.append(os.linesep)
            lines.append(line_to_make_present + os.linesep)

    def save_sudoers(self, lines):
        fd, path = tempfile.mkstemp()
        f = os.fdopen(fd, 'w+b')
        f.writelines(lines)
        f.close();
        self.device.sendline("visudo -c -f " + path)
        self.device.expect(path + ': parsed OK')
        if not(self.test):
            #atomic rename
            os.rename(path, "/etc/sudoers.d/testing_sudoers")

    def add_links_for_bins(self):
        bin_str = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'bin')
        bins = [ f for f in os.listdir(bin_str) if not(f.endswith('.sh')) ]
        for f in bins:
            bin_file = os.path.join(bin_str, f)
            command = "ln -fs %s /usr/bin/%s" % (bin_file, f)
            self.device.sendline('echo "%s"' % command)
            self.device.expect(FakeDevice.prompt)
            if not(self.test):
                self.device.sendline(command)
                self.device.expect(FakeDevice.prompt)

    def set_chmods(self):
        for f in ["/bin/ip", "/bin/ping", "/bin/ping6", "/sbin/xtables-multi", "/sbin/ifconfig"]:
            command = "chmod 4755 %s" % f
            self.device.sendline('echo "%s"'% command)
            self.device.expect(FakeDevice.prompt)
            if not(self.test):
                self.device.sendline(command)
                self.device.expect(FakeDevice.prompt)

    def local_dir(self, *path_parts):
        return os.path.join(os.path.dirname(os.path.abspath(__file__)),*path_parts)

    def add_to_startup(self):
        service_file = None
        filename = None
        if self.type == 'lan':
            filename = 'lan_setup.service'
        elif self.type == 'wan':
            filename = 'wan_setup.service'

        service_file = self.local_dir('conf', filename)

        command = "ln -f %s /etc/systemd/system/%s" % (service_file, filename)
        self.device.sendline('echo "%s"' % command)
        self.device.expect(FakeDevice.prompt)
        if not(self.test):
            self.device.sendline(command)
            self.device.expect(FakeDevice.prompt)
            self.device.sendline('systemctl enable %s' % filename)
            self.device.expect(FakeDevice.prompt)

    def setup_cron_for_dhclient_eth0(self):
        if not(self.test):
            self.device.sendline("ln -f %s /etc/systemd/system/%s" % (self.local_dir("conf", 'dhclient.eth0.service'), 'dhclient.eth0.service'))
            self.device.expect(FakeDevice.prompt)
            self.device.sendline('systemctl enable %s' % 'dhclient.eth0.service')
            self.device.expect(FakeDevice.prompt)
            self.device.sendline("ln -fs %s /etc/cron.d/boardfarm" % self.local_dir("conf", 'boardfarm_cron'))
            self.device.expect(FakeDevice.prompt)

    def check_if_root(self):
        self.device.sendline("id -u")
        try:
            self.device.expect('$0')
        except:
            print("This program must be running as root. Try running with 'sudo'")
            sys.exit(1)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Prepare to run this device as non-root',
                                     usage='prepare_for_non_root [options...]',
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("type", type=str, default=None, help="Set this device up as LAN device")
    parser.add_argument('-b', '--bin_dir', metavar='', type=str, default='/usr/bin', help='Directory where the links to your binaries. Defaults to "/usr/local/bin"')
    parser.add_argument('-u', '--user', metavar='', type=str, default='tester', help='Non-root user who has sudo access scripts. Default is "tester"')
    parser.add_argument('-y', '--no_prompts', action='store_true', help='Answer yes to all prompts. Used for automated systems')
    parser.add_argument('-t', '--run_test', action='store_true', help="Run a command as a test (development only)");

    args = parser.parse_args()

    if args.type != "lan" and args.type != "wan":
        print("You must choose LAN or WAN")
        parser.print_help();
        sys.exit(1)

    runner = SetupRunner(username=args.user, type=args.type, test=args.run_test)
    runner.check_if_root()
    runner.add_to_sudoers()

    runner.add_links_for_bins()
    runner.set_chmods()
    runner.add_to_startup()
    runner.setup_cron_for_dhclient_eth0()
